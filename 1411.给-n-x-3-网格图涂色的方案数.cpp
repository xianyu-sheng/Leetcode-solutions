class Solution {
public:
    int numOfWays(int n) {
        /*
            其实我们只是维持三列 那么为什么不就将这三列看作是一个状态呢？这比分别来
            考虑简单一些。
            实际上，比如对于一个一行三列的网格图，基于题目条件限制，如果我们需要涂色的话，那么我们其实有两种方案：
            第一种，“ABC”方案，那么第一个位置有三种方案，第二个位置就还有两种 第三个位置只能选择剩下的那个  那么3*2*1=6种
            第二种，“ABA”方案，那么第一个位置有三种方案（随便选） 第二个位置有来那个两种方案（不能与第一个位置相同）第三个位置只能跟改一个位置相同 6种方案
            因此 对于一行三列的网格涂色，那么就有12种方案

            那么此时我们在来思考多行的情况：
            1.假设我们计算的上一行是ABC方案：那么我们这一行使用ABA模式，一共两种方案
                                            使用ABC模式，那么一共有两种方案  合计4种
            2.假设上一行是ABA方案：那么我们这一行如果是ABA方案，就有三种方案
                                    如果是ABC方案，那么就一共有两种方案
            因此，根据我们前面的推算，那么我们对于第i行的状态可以通过下面的公式来计算
            1.第 i 行的 ABA 数量 =(上一行是ABA的数量 *3) + (上一行是ABC的数量 * 2)
            2.第 i 行的 ABC 数量 =(上一行是ABA的数量 * 2) + (上一行是ABC的数量 *2)
        */
        long long MOD = 1e9 + 7;
        //初始化n=1的情况
        long long typeABC=6;
        long long typeABA=6;

        //从第二行开始推导到n行
        for(int i=2;i<=n;i++){
            //先保存上一行的值
            long long prevABC=typeABC,prevABA=typeABA;
            //然后开始按公式计算
            typeABA = (prevABA * 3 + prevABC * 2) % MOD;
            typeABC = (prevABA * 2 + prevABC * 2) % MOD;
        }
        return (typeABA+typeABC)%MOD;
    }
};