/*
 * @lc app=leetcode.cn id=516 lang=cpp
 *
 * [516] 最长回文子序列
 */

// @lc code=start
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        /*
            题目理解：这里依然可以使用中心扩散法 不过这里的最长回文子序列如何理解 第一，需要是最长的，那么就可以逻辑的删除一些字符
            第二，要是回文的，必须要满足回文的条件
            第三，然后这里满足条件的可能不止一个，应该选出最长的  
            不过如何进行解题呢，我想一下 最长子序列是如何解题的呢  他是可以直接通过dp数组的递推公式然后就可以解决的   
            不过这里的最长回文子序列，是应该先判断是否是回文呢  然后在判断是否是最长呢   我们之前的最长公共子序列就是两个字符串一起来参加这个dp数组的推导 不过我这里并不想使用dp数组 或许也需要在中心扩散法的调用函数中使用dp数组作为动态规划的基础 因为这里哪怕你使用中心扩散法，然后从一个字符串开始判断走，这里采用的是双指针，那么在不等的时候，是左指针动还是右指针动呢  这是一个很复杂的问题我认为 如果这样思考的话


            下面我再来理解一下这个问题 我感觉按照上面的陈述，把问题过于实际化了 反而增加解题难度  不过我能否在上面的中心探测法的调用函数里面 也就是判断是否为回文串的里面 小小的修改一下 就可以改变为判断最长的回文子串  即在如果不等的情况下，通过探测法进行判断下一次是左指针动还是右指针动  即先判断比如[i-1]是否等于[j]这样的样式 这么思考可行吗

            深刻洞察：一个字符串的最长回文字系列=该字符串与其反转后的字符串的最长公共子序列
        */

        int  n=s.size();
        vector<vector<int>> dp(n,vector<int>(n,0));
        for (int i = n - 1; i >= 0; i--) {           // i 从下往上
            dp[i][i] = 1;                            // 初始化：单个字符
            for (int j = i + 1; j < n; j++) {        // j 从 i+1 开始，向右扩展
                if (s[i] == s[j]) {
                    dp[i][j] = dp[i+1][j-1] + 2;
                } else {
                    dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
                }
            }
        }
        return dp[0][n-1];
    }
};
// @lc code=end

